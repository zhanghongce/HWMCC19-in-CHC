

;----------------------------------------
;  CHC generated from BTOR
;  Generated by COSA2 (Pono)
;----------------------------------------

(set-option :fp.engine spacer)

(define-fun Init 
    ((state33 (_ BitVec 128)) (state31 (_ BitVec 128)) (state27 (_ BitVec 1)) (state11 (_ BitVec 256)) (state29 (_ BitVec 1)) (state23 (_ BitVec 128)) (state13 (_ BitVec 256)) (state25 (_ BitVec 128)) (input8 (_ BitVec 1)) (input7 (_ BitVec 128)) (input6 (_ BitVec 128)) (input4 (_ BitVec 1)) (input2 (_ BitVec 1)) (input3 (_ BitVec 1)))
     Bool
     (and (and (and (and (and (and (and (= state11 (_ bv0 256)) (= state13 (_ bv0 256))) (= state23 (_ bv0 128))) (= state25 (_ bv0 128))) (= state27 (_ bv1 1))) (= state29 (_ bv1 1))) (= state31 (_ bv0 128))) (= state33 (_ bv0 128))))
(define-fun Trans 
    ((state33 (_ BitVec 128)) (state31 (_ BitVec 128)) (state27 (_ BitVec 1)) (state11 (_ BitVec 256)) (state29 (_ BitVec 1)) (state23 (_ BitVec 128)) (state13 (_ BitVec 256)) (state25 (_ BitVec 128)) (input8 (_ BitVec 1)) (input7 (_ BitVec 128)) (input6 (_ BitVec 128)) (input4 (_ BitVec 1)) (input2 (_ BitVec 1)) (input3 (_ BitVec 1)) (state33.next (_ BitVec 128)) (state31.next (_ BitVec 128)) (state27.next (_ BitVec 1)) (state11.next (_ BitVec 256)) (state29.next (_ BitVec 1)) (state23.next (_ BitVec 128)) (state13.next (_ BitVec 256)) (state25.next (_ BitVec 128)) (input8.next (_ BitVec 1)) (input7.next (_ BitVec 128)) (input6.next (_ BitVec 128)) (input4.next (_ BitVec 1)) (input2.next (_ BitVec 1)) (input3.next (_ BitVec 1)))
    Bool
     (let ((.def_65 (= input8 (_ bv1 1)))) (let ((.def_77 (= input3 (_ bv1 1)))) (let ((.def_82 (= input4 (_ bv1 1)))) (and (and (and (and (and (and (and (= state11.next (ite .def_65 (_ bv0 256) (bvmul ((_ zero_extend 128) state23) ((_ zero_extend 128) state25)))) (= state13.next (ite .def_65 (_ bv0 256) (ite (= (bvor state27 state29) (_ bv1 1)) (bvmul ((_ zero_extend 128) state31) ((_ zero_extend 128) state33)) state13)))) (= state23.next (ite .def_65 (_ bv0 128) (ite .def_77 input6 state23)))) (= state25.next (ite .def_65 (_ bv0 128) (ite .def_82 input7 state25)))) (= state27.next (ite .def_65 (_ bv1 1) input3))) (= state29.next (ite .def_65 (_ bv1 1) input4))) (= state31.next (ite .def_65 (_ bv0 128) (ite .def_77 input6 state31)))) (= state33.next (ite .def_65 (_ bv0 128) (ite .def_82 input7 state33))))))))
(define-fun P 
   ((state33 (_ BitVec 128)) (state31 (_ BitVec 128)) (state27 (_ BitVec 1)) (state11 (_ BitVec 256)) (state29 (_ BitVec 1)) (state23 (_ BitVec 128)) (state13 (_ BitVec 256)) (state25 (_ BitVec 128)) (input8 (_ BitVec 1)) (input7 (_ BitVec 128)) (input6 (_ BitVec 128)) (input4 (_ BitVec 1)) (input2 (_ BitVec 1)) (input3 (_ BitVec 1)))
    Bool
     (not (= (bvcomp state11 state13) (_ bv0 1))))

(declare-var state33 (_ BitVec 128))
(declare-var state31 (_ BitVec 128))
(declare-var state27 (_ BitVec 1))
(declare-var state11 (_ BitVec 256))
(declare-var state29 (_ BitVec 1))
(declare-var state23 (_ BitVec 128))
(declare-var state13 (_ BitVec 256))
(declare-var state25 (_ BitVec 128))

(declare-var state33.next (_ BitVec 128))
(declare-var state31.next (_ BitVec 128))
(declare-var state27.next (_ BitVec 1))
(declare-var state11.next (_ BitVec 256))
(declare-var state29.next (_ BitVec 1))
(declare-var state23.next (_ BitVec 128))
(declare-var state13.next (_ BitVec 256))
(declare-var state25.next (_ BitVec 128))

(declare-var input8 (_ BitVec 1))
(declare-var input7 (_ BitVec 128))
(declare-var input6 (_ BitVec 128))
(declare-var input4 (_ BitVec 1))
(declare-var input2 (_ BitVec 1))
(declare-var input3 (_ BitVec 1))
(declare-var input8.next (_ BitVec 1))
(declare-var input7.next (_ BitVec 128))
(declare-var input6.next (_ BitVec 128))
(declare-var input4.next (_ BitVec 1))
(declare-var input2.next (_ BitVec 1))
(declare-var input3.next (_ BitVec 1))


(declare-rel INV ((_ BitVec 128) (_ BitVec 128) (_ BitVec 1) (_ BitVec 256) (_ BitVec 1) (_ BitVec 128) (_ BitVec 256) (_ BitVec 128) (_ BitVec 1) (_ BitVec 128) (_ BitVec 128) (_ BitVec 1) (_ BitVec 1) (_ BitVec 1)))
(declare-rel fail ())

(rule (=> 
  (Init state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)
  (INV  state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)))

(rule (=> (and
  (INV  state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)
  (Trans state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3 state33.next state31.next state27.next state11.next state29.next state23.next state13.next state25.next input8.next input7.next input6.next input4.next input2.next input3.next))
  (INV  state33.next state31.next state27.next state11.next state29.next state23.next state13.next state25.next input8.next input7.next input6.next input4.next input2.next input3.next)))

(rule (=> (and
  (INV state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3) 
  (not (P state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)))
  fail))

(query fail :print-certificate true)

