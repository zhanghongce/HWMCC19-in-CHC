

;----------------------------------------
;  CHC generated from BTOR
;  Generated by COSA2 (Pono)
;----------------------------------------

(set-option :fp.engine spacer)

(define-fun Init 
    ((state33 (_ BitVec 32)) (state31 (_ BitVec 32)) (state27 (_ BitVec 1)) (state11 (_ BitVec 64)) (state29 (_ BitVec 1)) (state23 (_ BitVec 32)) (state13 (_ BitVec 64)) (state25 (_ BitVec 32)) (input8 (_ BitVec 1)) (input7 (_ BitVec 32)) (input6 (_ BitVec 32)) (input4 (_ BitVec 1)) (input2 (_ BitVec 1)) (input3 (_ BitVec 1)))
     Bool
     (and (and (and (and (and (and (and (= state11 (_ bv0 64)) (= state13 (_ bv0 64))) (= state23 (_ bv0 32))) (= state25 (_ bv0 32))) (= state27 (_ bv1 1))) (= state29 (_ bv1 1))) (= state31 (_ bv0 32))) (= state33 (_ bv0 32))))
(define-fun Trans 
    ((state33 (_ BitVec 32)) (state31 (_ BitVec 32)) (state27 (_ BitVec 1)) (state11 (_ BitVec 64)) (state29 (_ BitVec 1)) (state23 (_ BitVec 32)) (state13 (_ BitVec 64)) (state25 (_ BitVec 32)) (input8 (_ BitVec 1)) (input7 (_ BitVec 32)) (input6 (_ BitVec 32)) (input4 (_ BitVec 1)) (input2 (_ BitVec 1)) (input3 (_ BitVec 1)) (state33.next (_ BitVec 32)) (state31.next (_ BitVec 32)) (state27.next (_ BitVec 1)) (state11.next (_ BitVec 64)) (state29.next (_ BitVec 1)) (state23.next (_ BitVec 32)) (state13.next (_ BitVec 64)) (state25.next (_ BitVec 32)) (input8.next (_ BitVec 1)) (input7.next (_ BitVec 32)) (input6.next (_ BitVec 32)) (input4.next (_ BitVec 1)) (input2.next (_ BitVec 1)) (input3.next (_ BitVec 1)))
    Bool
     (let ((.def_65 (= input8 (_ bv1 1)))) (let ((.def_77 (= input3 (_ bv1 1)))) (let ((.def_82 (= input4 (_ bv1 1)))) (and (and (and (and (and (and (and (= state11.next (ite .def_65 (_ bv0 64) (bvmul ((_ zero_extend 32) state23) ((_ zero_extend 32) state25)))) (= state13.next (ite .def_65 (_ bv0 64) (ite (= (bvor state27 state29) (_ bv1 1)) (bvmul ((_ zero_extend 32) state31) ((_ zero_extend 32) state33)) state13)))) (= state23.next (ite .def_65 (_ bv0 32) (ite .def_77 input6 state23)))) (= state25.next (ite .def_65 (_ bv0 32) (ite .def_82 input7 state25)))) (= state27.next (ite .def_65 (_ bv1 1) input3))) (= state29.next (ite .def_65 (_ bv1 1) input4))) (= state31.next (ite .def_65 (_ bv0 32) (ite .def_77 input6 state31)))) (= state33.next (ite .def_65 (_ bv0 32) (ite .def_82 input7 state33))))))))
(define-fun P 
   ((state33 (_ BitVec 32)) (state31 (_ BitVec 32)) (state27 (_ BitVec 1)) (state11 (_ BitVec 64)) (state29 (_ BitVec 1)) (state23 (_ BitVec 32)) (state13 (_ BitVec 64)) (state25 (_ BitVec 32)) (input8 (_ BitVec 1)) (input7 (_ BitVec 32)) (input6 (_ BitVec 32)) (input4 (_ BitVec 1)) (input2 (_ BitVec 1)) (input3 (_ BitVec 1)))
    Bool
     (not (= (bvcomp state11 state13) (_ bv0 1))))

(declare-var state33 (_ BitVec 32))
(declare-var state31 (_ BitVec 32))
(declare-var state27 (_ BitVec 1))
(declare-var state11 (_ BitVec 64))
(declare-var state29 (_ BitVec 1))
(declare-var state23 (_ BitVec 32))
(declare-var state13 (_ BitVec 64))
(declare-var state25 (_ BitVec 32))

(declare-var state33.next (_ BitVec 32))
(declare-var state31.next (_ BitVec 32))
(declare-var state27.next (_ BitVec 1))
(declare-var state11.next (_ BitVec 64))
(declare-var state29.next (_ BitVec 1))
(declare-var state23.next (_ BitVec 32))
(declare-var state13.next (_ BitVec 64))
(declare-var state25.next (_ BitVec 32))

(declare-var input8 (_ BitVec 1))
(declare-var input7 (_ BitVec 32))
(declare-var input6 (_ BitVec 32))
(declare-var input4 (_ BitVec 1))
(declare-var input2 (_ BitVec 1))
(declare-var input3 (_ BitVec 1))
(declare-var input8.next (_ BitVec 1))
(declare-var input7.next (_ BitVec 32))
(declare-var input6.next (_ BitVec 32))
(declare-var input4.next (_ BitVec 1))
(declare-var input2.next (_ BitVec 1))
(declare-var input3.next (_ BitVec 1))


(declare-rel INV ((_ BitVec 32) (_ BitVec 32) (_ BitVec 1) (_ BitVec 64) (_ BitVec 1) (_ BitVec 32) (_ BitVec 64) (_ BitVec 32) (_ BitVec 1) (_ BitVec 32) (_ BitVec 32) (_ BitVec 1) (_ BitVec 1) (_ BitVec 1)))
(declare-rel fail ())

(rule (=> 
  (Init state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)
  (INV  state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)))

(rule (=> (and
  (INV  state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)
  (Trans state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3 state33.next state31.next state27.next state11.next state29.next state23.next state13.next state25.next input8.next input7.next input6.next input4.next input2.next input3.next))
  (INV  state33.next state31.next state27.next state11.next state29.next state23.next state13.next state25.next input8.next input7.next input6.next input4.next input2.next input3.next)))

(rule (=> (and
  (INV state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3) 
  (not (P state33 state31 state27 state11 state29 state23 state13 state25 input8 input7 input6 input4 input2 input3)))
  fail))

(query fail :print-certificate true)

